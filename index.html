<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8">
<title>GTA Log Creator V42 (Adjustable Censor)</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

<style>
  /* --- CSS Styles --- */
  body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #121212; color: #e0e0e0; padding: 20px; margin: 0; display: flex; flex-direction: column; align-items: center; }
  h2 { margin-bottom: 10px; color: #ffffff; text-shadow: 0 0 10px rgba(155, 89, 182, 0.5); }

  .container { 
    display: flex; flex-direction: column; gap: 20px; 
    width: 100%; max-width: 1400px; 
    justify-content: center; align-items: center; 
  }
  
  /* Canvas Area */
  .canvas-area { width: 100%; display: flex; flex-direction: column; align-items: center; }
  .canvas-wrapper { 
    position: relative; border: 2px solid #333; background: #000; 
    box-shadow: 0 15px 40px rgba(0,0,0,0.6); line-height: 0;
    max-width: 100%; min-height: 200px; max-height: 80vh; overflow: hidden;
    user-select: none;
  }
  canvas { max-width: 100%; height: auto; display: block; background: #111; }

  /* Scene Tabs */
  .scene-bar {
    display: flex; gap: 8px; width: 100%; overflow-x: auto; 
    padding: 15px 0; align-items: center; justify-content: flex-start;
    scrollbar-width: thin; scrollbar-color: #444 #222;
  }
  
  .scene-btn {
    min-width: 60px; height: 36px; border-radius: 6px 6px 0 0; 
    border: 1px solid #444; border-bottom: none;
    background: #2c2c2c; color: #aaa; cursor: pointer; font-weight: bold; font-size: 13px;
    display: flex; align-items: center; justify-content: space-between; 
    padding: 0 10px; transition: 0.2s; white-space: nowrap; user-select: none;
  }
  .scene-btn:hover { background: #3a3a3a; color: #fff; }
  .scene-btn.active { 
    background: #9b59b6; color: white; border-color: #be7dd6; 
    box-shadow: 0 -2px 10px rgba(155, 89, 182, 0.2); 
    transform: translateY(-2px);
  }
  
  .scene-close {
    width: 20px; height: 20px; border-radius: 50%; 
    display: flex; align-items: center; justify-content: center;
    margin-left: 8px; font-size: 14px; color: #ddd; opacity: 0.6;
    background: rgba(255,255,255,0.1);
  }
  .scene-close:hover { background: #c0392b; color: white; opacity: 1; }

  .scene-add-btn {
    min-width: 36px; height: 36px; background: #27ae60; color: white; 
    border: none; border-radius: 50%; cursor: pointer; font-size: 20px;
    display: flex; align-items: center; justify-content: center; flex-shrink: 0;
  }
  .scene-add-btn:hover { transform: scale(1.1); background: #2ecc71; }

  /* Controls */
  .controls { 
    width: 100%; background: #1e1e1e; padding: 20px; border-radius: 12px; border: 1px solid #333;
    display: grid; grid-template-columns: 1.5fr 1fr 0.8fr; gap: 25px; box-sizing: border-box;
  }
  @media (max-width: 900px) { .controls { grid-template-columns: 1fr; } }

  .col-text { display: flex; flex-direction: column; gap: 10px; }
  .col-settings { display: flex; flex-direction: column; gap: 12px; }
  .col-actions { display: flex; flex-direction: column; gap: 12px; justify-content: flex-start; }

  label { display: block; margin-bottom: 4px; font-size: 13px; color: #aaa; font-weight: 600; }
  input[type="text"], input[type="number"], textarea, input[type="range"] {
    width: 100%; padding: 10px; background: #2c2c2c; border: 1px solid #444; color: #fff; border-radius: 6px; box-sizing: border-box; font-family: sans-serif; transition: 0.2s;
  }
  input:focus, textarea:focus { outline: none; border-color: #9b59b6; background: #333; }
  textarea { height: 100%; min-height: 150px; resize: vertical; font-size: 14px; line-height: 1.4; border-top-left-radius: 0; border-top-right-radius: 0; }

  /* Text Block Controls */
  .text-block-controls {
    display: flex; align-items: center; justify-content: space-between;
    background: #333; padding: 5px 10px; border-radius: 6px 6px 0 0; border: 1px solid #444; border-bottom: none;
  }
  .tb-title { font-size: 12px; font-weight: bold; color: #fff; }
  .tb-actions button {
    background: #444; border: none; color: #ddd; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 11px; margin-left: 4px;
  }
  .tb-actions button:hover { background: #555; color: white; }
  .tb-actions button.btn-add { background: #27ae60; color: white; }
  .tb-actions button.btn-del { background: #c0392b; color: white; }

  /* Mode Buttons */
  .mode-group { display: flex; background: #2c2c2c; border-radius: 8px; padding: 4px; border: 1px solid #444; }
  .mode-btn { flex: 1; padding: 8px; border: none; background: transparent; color: #888; cursor: pointer; font-weight: bold; border-radius: 6px; transition: 0.2s; font-size: 13px; }
  .mode-btn.active { background: #9b59b6; color: white; }
  .mode-btn.active-censor { background: #e67e22; color: white; }

  /* Action Buttons Group */
  .download-group { display: flex; gap: 10px; width: 100%; }

  .btn-download { 
    padding: 15px; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; font-size: 14px; flex: 1; box-shadow: 0 4px 15px rgba(0,0,0,0.3); transition: 0.2s; color: white;
  }
  .btn-zip { background: linear-gradient(135deg, #9b59b6, #8e44ad); }
  .btn-single { background: linear-gradient(135deg, #3498db, #2980b9); }

  .btn-download:hover { transform: translateY(-2px); opacity: 0.9; }
  .btn-download.loading { background: #555; cursor: wait; }
  
  .btn-reset { padding: 10px; background: #444; color: #ccc; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; width: 100%; margin-top: 5px;}
  .btn-reset:hover { background: #555; color: white; }

  .checkbox-row { display: flex; gap: 15px; background: #252525; padding: 10px; border-radius: 6px; border: 1px solid #333; }
  .cb-item { display: flex; align-items: center; cursor: pointer; font-size: 13px; user-select: none; }
  .cb-item input { margin-right: 8px; accent-color: #9b59b6; width: 16px; height: 16px; }

  .row { display: flex; gap: 10px; }
  .helper-text { font-size: 12px; color: #777; text-align: center; margin-top: 8px; width: 100%; }
  
  /* Censor Helper */
  .censor-tools { display: none; gap: 5px; margin-top: 5px; }
  .show-censor .censor-tools { display: flex; }
  .btn-censor-action { flex: 1; font-size: 12px; padding: 8px; border: none; border-radius: 4px; cursor: pointer; color: white; }
  .btn-undo { background: #f39c12; }
  .btn-clear { background: #c0392b; }
</style>
</head>
<body>

  <h2>GTA Log Creator V42 (Adjustable Pixels)</h2>

  <div class="container">
    <div class="canvas-area">
      <div class="canvas-wrapper">
        <canvas id="canvas" width="800" height="600"></canvas>
      </div>
      <div class="scene-bar" id="sceneContainer">
        <button class="scene-add-btn" onclick="app.addNewScene()" title="‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ã‡∏µ‡∏ô‡πÉ‡∏´‡∏°‡πà">+</button>
      </div>
      <p class="helper-text" id="statusText">
        ‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏ã‡πá‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå: ‡∏•‡∏≤‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏ö‡∏•‡∏≠ | <b>‡∏ä‡∏µ‡πâ‡∏ó‡∏µ‡πà‡∏£‡∏≠‡∏¢‡πÄ‡∏ö‡∏•‡∏≠‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏•‡∏¥‡∏Å‡∏Ç‡∏ß‡∏≤‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏•‡∏ö</b>
      </p>
    </div>

    <div class="controls">
      
      <div class="col-text">
        <label>‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° Log (Multi-Block)</label>
        
        <div class="text-block-controls">
          <span class="tb-title" id="activeBlockLabel">Editing Block #1</span>
          <div class="tb-actions">
            <button onclick="app.cycleBlock(-1)">‚óÄ</button>
            <button onclick="app.cycleBlock(1)">‚ñ∂</button>
            <button class="btn-add" onclick="app.addTextBlock()">+ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏•‡πà‡∏≠‡∏á</button>
            <button class="btn-del" onclick="app.deleteTextBlock()">‡∏•‡∏ö‡∏Å‡∏•‡πà‡∏≠‡∏á</button>
          </div>
        </div>

        <textarea id="textInput" placeholder="‡∏ß‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° Log ‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà...&#10;‡πÄ‡∏ä‡πà‡∏ô:&#10;John says (‡πÇ‡∏ó‡∏£‡∏®‡∏±‡∏û‡∏ó‡πå): ‡∏Æ‡∏±‡∏•‡πÇ‡∏´‡∏•&#10;* John ‡∏´‡∏¢‡∏¥‡∏ö‡πÇ‡∏ó‡∏£‡∏®‡∏±‡∏û‡∏ó‡πå"></textarea>
      </div>

      <div class="col-settings">
        <div>
          <label>‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠ (Tool Mode)</label>
          <div class="mode-group" id="modeGroup">
            <button class="mode-btn active" onclick="app.setMode('move')">‚úã ‡∏Ç‡∏¢‡∏±‡∏ö/‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</button>
            <button class="mode-btn" onclick="app.setMode('censor')">üõ°Ô∏è ‡πÄ‡∏ã‡πá‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå</button>
          </div>
          <div class="censor-tools" id="censorTools">
             <button class="btn-censor-action btn-undo" onclick="app.undoCensor()">‚Ü© ‡∏•‡∏ö‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î</button>
             <button class="btn-censor-action btn-clear" onclick="app.clearAllCensors()">üóëÔ∏è ‡∏•‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</button>
          </div>
        </div>

        <div>
          <label>‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡πÄ‡∏ã‡πá‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå (Pixel Size)</label>
          <input type="range" id="pixelSize" min="2" max="50" value="10" step="1">
          <div style="font-size:10px; color:#777; text-align:right;" id="pixelVal">10px</div>
        </div>

        <div class="row">
          <div style="flex:1">
             <label>‡∏Ç‡∏ô‡∏≤‡∏î‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£</label>
             <input type="number" id="fontSize" value="13">
          </div>
          <div style="flex:1">
             <label>‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î (px)</label>
             <input type="number" id="lineSpacing" value="8">
          </div>
        </div>

        <div class="row">
          <div style="flex:1">
             <label>‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°</label>
             <input type="range" id="textWrapWidth" min="200" max="2000" value="800" step="10">
             <div style="font-size:10px; color:#777; text-align:right;" id="wrapVal">800px</div>
          </div>
        </div>

        <div class="checkbox-row">
          <label class="cb-item"><input type="checkbox" id="showBg" checked> ‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏î‡∏≥</label>
          <label class="cb-item"><input type="checkbox" id="showStroke" checked> ‡∏Ç‡∏≠‡∏ö‡∏ï‡∏±‡∏ß‡∏´‡∏ô‡∏±‡∏á‡∏™‡∏∑‡∏≠</label>
        </div>
      </div>

      <div class="col-actions">
        <div>
          <label>‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û</label>
          <input type="file" id="upload" accept="image/*">
        </div>

        <div class="row">
          <div style="flex:1">
              <label>‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á (W)</label>
              <input type="number" id="cWidth" value="800">
          </div>
          <div style="flex:1">
              <label>‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á (H)</label>
              <input type="number" id="cHeight" value="600">
          </div>
        </div>
        
        <button class="btn-reset" onclick="app.resetCurrentPos()">‚Ü∫ ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á</button>

        <label style="margin-top:10px;">‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û</label>
        <div class="download-group">
           <button class="btn-download btn-single" onclick="app.downloadCurrentScene()">‚¨á ‡∏£‡∏π‡∏õ‡∏ô‡∏µ‡πâ (PNG)</button>
           <button class="btn-download btn-zip" id="downloadBtn" onclick="app.downloadAllScenes()">üì¶ ZIP (‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î)</button>
        </div>
      </div>

    </div>
  </div>

<script>
  const app = {
    canvas: null,
    ctx: null,
    els: {},
    scenes: [],
    currentSceneIndex: 0,
    
    // State
    isDragging: false,
    dragTarget: null, 
    dragStart: { x: 0, y: 0 },
    
    // Censor State
    mode: 'move', 
    isCensoring: false,
    censorStart: { x: 0, y: 0 },
    censorCurrent: { x: 0, y: 0 },
    hoveredCensorIndex: -1,
    
    // Export State
    isDownloading: false,

    init: function() {
      this.canvas = document.getElementById('canvas');
      this.ctx = this.canvas.getContext('2d');
      
      this.els = {
        text: document.getElementById('textInput'),
        size: document.getElementById('fontSize'),
        spacing: document.getElementById('lineSpacing'),
        wrap: document.getElementById('textWrapWidth'),
        wrapVal: document.getElementById('wrapVal'),
        width: document.getElementById('cWidth'),
        height: document.getElementById('cHeight'),
        bg: document.getElementById('showBg'),
        stroke: document.getElementById('showStroke'),
        upload: document.getElementById('upload'),
        sceneContainer: document.getElementById('sceneContainer'),
        downloadBtn: document.getElementById('downloadBtn'),
        blockLabel: document.getElementById('activeBlockLabel'),
        censorTools: document.getElementById('censorTools'),
        pixelSize: document.getElementById('pixelSize'),
        pixelVal: document.getElementById('pixelVal'),
        modeBtns: document.querySelectorAll('.mode-btn')
      };

      this.addNewScene(true);
      this.setupEvents();
      this.resizeCanvas();
    },

    // --- Data Structures ---
    Scene: class {
      constructor(copyFrom = null) {
        this.img = copyFrom ? copyFrom.img : null;
        this.imgLoaded = copyFrom ? copyFrom.imgLoaded : false;
        this.imgX = copyFrom ? copyFrom.imgX : 0;
        this.imgY = copyFrom ? copyFrom.imgY : 0;
        this.imgScale = copyFrom ? copyFrom.imgScale : 1;
        
        // Censors
        this.censoredAreas = copyFrom ? JSON.parse(JSON.stringify(copyFrom.censoredAreas)) : [];
        this.pixelSize = copyFrom ? copyFrom.pixelSize : 10; // Default Pixel Size

        // Text Blocks
        if (copyFrom) {
            this.blocks = copyFrom.blocks.map(b => ({...b}));
            this.activeBlockIndex = copyFrom.activeBlockIndex;
        } else {
            this.blocks = [{ text: "", x: 20, y: 20, width: 800, height: 0, bounds: null }];
            this.activeBlockIndex = 0;
        }
        
        // Shared Settings
        this.fontSize = copyFrom ? copyFrom.fontSize : 13;
        this.lineSpacing = copyFrom ? copyFrom.lineSpacing : 8;
        this.textWrap = copyFrom ? copyFrom.textWrap : 800;
      }
    },

    // --- Scene Management ---
    addNewScene: function(isFirst = false) {
      const prevScene = !isFirst && this.scenes[this.currentSceneIndex] ? this.scenes[this.currentSceneIndex] : null;
      const newScene = new this.Scene(prevScene);
      this.scenes.push(newScene);
      this.switchScene(this.scenes.length - 1);
    },

    deleteScene: function(index) {
      if (this.scenes.length <= 1) { alert("‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 1 ‡∏ã‡∏µ‡∏ô‡∏Ñ‡∏£‡∏±‡∏ö"); return; }
      if (confirm(`‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏•‡∏ö‡∏ã‡∏µ‡∏ô‡∏ó‡∏µ‡πà ${index + 1}?`)) {
        this.scenes.splice(index, 1);
        if (index === this.currentSceneIndex) {
          this.currentSceneIndex = Math.max(0, index - 1);
        } else if (index < this.currentSceneIndex) {
          this.currentSceneIndex--;
        }
        this.switchScene(this.currentSceneIndex);
      }
    },

    switchScene: function(index) {
      if (index < 0) index = 0;
      if (index >= this.scenes.length) index = this.scenes.length - 1;
      this.currentSceneIndex = index;
      const sc = this.scenes[this.currentSceneIndex];
      
      this.updateBlockUI();
      this.els.size.value = sc.fontSize;
      this.els.spacing.value = sc.lineSpacing;
      this.els.wrap.value = sc.textWrap;
      this.els.wrapVal.innerText = sc.textWrap + 'px';
      
      // Update Pixel Slider
      this.els.pixelSize.value = sc.pixelSize;
      this.els.pixelVal.innerText = sc.pixelSize + 'px';
      
      this.updateSceneUI();
      this.draw();
    },

    updateSceneUI: function() {
      const existing = document.querySelectorAll('.scene-btn');
      existing.forEach(el => el.remove());
      this.scenes.forEach((_, idx) => {
        const btn = document.createElement('div');
        btn.className = `scene-btn ${idx === this.currentSceneIndex ? 'active' : ''}`;
        btn.innerHTML = `Scene ${idx + 1} <span class="scene-close" onclick="app.deleteScene(${idx}, event)">√ó</span>`;
        btn.onclick = () => this.switchScene(idx);
        this.els.sceneContainer.insertBefore(btn, this.els.sceneContainer.querySelector('.scene-add-btn'));
      });
    },

    // --- Block Management ---
    getActiveBlock: function() {
        const sc = this.scenes[this.currentSceneIndex];
        return sc.blocks[sc.activeBlockIndex];
    },

    addTextBlock: function() {
        const sc = this.scenes[this.currentSceneIndex];
        sc.blocks.push({ text: "‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÉ‡∏´‡∏°‡πà...", x: 50, y: 50, width: 800, height: 0, bounds: null });
        sc.activeBlockIndex = sc.blocks.length - 1;
        this.updateBlockUI();
        this.draw();
    },

    deleteTextBlock: function() {
        const sc = this.scenes[this.currentSceneIndex];
        if (sc.blocks.length <= 1) { alert("‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÑ‡∏ß‡πâ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 1 ‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏Ñ‡∏£‡∏±‡∏ö"); return; }
        sc.blocks.splice(sc.activeBlockIndex, 1);
        sc.activeBlockIndex = Math.max(0, sc.activeBlockIndex - 1);
        this.updateBlockUI();
        this.draw();
    },

    cycleBlock: function(dir) {
        const sc = this.scenes[this.currentSceneIndex];
        let newIdx = sc.activeBlockIndex + dir;
        if (newIdx < 0) newIdx = sc.blocks.length - 1;
        if (newIdx >= sc.blocks.length) newIdx = 0;
        sc.activeBlockIndex = newIdx;
        this.updateBlockUI();
        this.draw(); 
    },

    updateBlockUI: function() {
        const sc = this.scenes[this.currentSceneIndex];
        const block = sc.blocks[sc.activeBlockIndex];
        this.els.text.value = block.text;
        this.els.blockLabel.innerText = `‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° ${sc.activeBlockIndex + 1} / ${sc.blocks.length}`;
    },

    // --- Censor Logic ---
    undoCensor: function() {
        const sc = this.scenes[this.currentSceneIndex];
        if (sc.censoredAreas.length > 0) {
            sc.censoredAreas.pop();
            this.draw();
        }
    },

    clearAllCensors: function() {
        const sc = this.scenes[this.currentSceneIndex];
        if (sc.censoredAreas.length > 0 && confirm("‡∏•‡∏ö‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏ã‡πá‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡∏ã‡∏µ‡∏ô‡∏ô‡∏µ‡πâ?")) {
            sc.censoredAreas = [];
            this.draw();
        }
    },

    // --- Drawing Core ---
    resizeCanvas: function() {
      this.canvas.width = parseInt(this.els.width.value) || 800;
      this.canvas.height = parseInt(this.els.height.value) || 600;
      this.draw();
    },

    draw: function() {
      const sc = this.scenes[this.currentSceneIndex];
      if (!sc) return;
      
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      if (sc.imgLoaded && sc.img) {
        this.ctx.drawImage(sc.img, sc.imgX, sc.imgY, sc.img.width * sc.imgScale, sc.img.height * sc.imgScale);
      } else {
        this.drawPlaceholder();
      }

      // Draw Pixels
      if (sc.censoredAreas.length > 0) {
          sc.censoredAreas.forEach(area => this.pixelateArea(area.x, area.y, area.w, area.h));
      }
      
      // Draw UI Overlays (STRICTLY CHECK !this.isDownloading)
      if (!this.isDownloading) {
          
          // 1. Hovered Censor (Red Outline)
          if (this.mode === 'censor' && this.hoveredCensorIndex !== -1 && sc.censoredAreas[this.hoveredCensorIndex]) {
              const area = sc.censoredAreas[this.hoveredCensorIndex];
              this.ctx.strokeStyle = "#c0392b"; 
              this.ctx.lineWidth = 2;
              this.ctx.setLineDash([5, 3]);
              this.ctx.strokeRect(area.x, area.y, area.w, area.h);
              this.ctx.setLineDash([]);
          }

          // 2. Dragging New Censor (Orange Box)
          if (this.isCensoring && this.mode === 'censor') {
              const w = this.censorCurrent.x - this.censorStart.x;
              const h = this.censorCurrent.y - this.censorStart.y;
              this.ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
              this.ctx.fillRect(this.censorStart.x, this.censorStart.y, w, h);
              this.ctx.strokeStyle = "#e67e22";
              this.ctx.lineWidth = 2;
              this.ctx.strokeRect(this.censorStart.x, this.censorStart.y, w, h);
          }
      }

      sc.blocks.forEach((block, idx) => {
          this.drawTextBlock(sc, block, idx === sc.activeBlockIndex);
      });
    },

    pixelateArea: function(x, y, w, h) {
        if (w === 0 || h === 0) return;
        const sc = this.scenes[this.currentSceneIndex];
        const sampleSize = sc.pixelSize || 10; // Use user defined size or default 10

        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        
        const rx = Math.floor(w < 0 ? x + w : x);
        const ry = Math.floor(h < 0 ? y + h : y);
        const rw = Math.abs(w);
        const rh = Math.abs(h);

        tempCanvas.width = rw;
        tempCanvas.height = rh;
        
        // Draw slice of original image
        tempCtx.drawImage(this.canvas, rx, ry, rw, rh, 0, 0, rw, rh);

        // Turn off smoothing to get pixel look
        this.ctx.imageSmoothingEnabled = false;
        
        // Calculate scaled down size
        const sw = Math.max(1, Math.floor(rw / sampleSize));
        const sh = Math.max(1, Math.floor(rh / sampleSize));
        
        // Draw small, then draw back big
        this.ctx.drawImage(tempCanvas, 0, 0, rw, rh, rx, ry, sw, sh);
        this.ctx.drawImage(this.canvas, rx, ry, sw, sh, rx, ry, rw, rh);
        
        this.ctx.imageSmoothingEnabled = true;
    },

    drawPlaceholder: function() {
      this.ctx.fillStyle = "#1a1a1a"; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      this.ctx.fillStyle = "#444"; this.ctx.font = "20px sans-serif"; this.ctx.textAlign = "center"; this.ctx.textBaseline = "middle";
      this.ctx.fillText(`Scene ${this.currentSceneIndex + 1}`, this.canvas.width/2, this.canvas.height/2);
    },

    drawTextBlock: function(scene, block, isActive) {
      if (!block.text) { block.bounds = null; return; }

      const fontSize = parseInt(this.els.size.value) || 13;
      const spacing = parseInt(this.els.spacing.value) || 8;
      const wrapWidth = parseInt(this.els.wrap.value) || 800;
      
      const lineHeight = fontSize + spacing; 
      
      const cAction = "#C2A2DA"; 
      const cNormal = "#FFFFFF"; 
      const cWhisper = "#BDBDBD"; 
      const cPhone = "#FFFF00";  
      const cInfo = "#5da3e3";   
      const cMoney = "#33AA33";  

      this.ctx.font = `600 ${fontSize}px sans-serif`;
      this.ctx.textBaseline = "top";
      this.ctx.textAlign = "left";

      const lines = block.text.split('\n');
      let currentY = block.y;
      let maxWidth = 0;

      const startY = currentY;

      lines.forEach(line => {
          let text = line.trim();
          let lowerText = text.toLowerCase();
          
          let baseColor = cNormal; 
          let isAction = false; 

          // Logic Order
          if (text.startsWith('*') || text.startsWith('>') || 
              lowerText.startsWith('(phone) *') || lowerText.startsWith('(phone)*') ||
              lowerText.startsWith('(‡πÇ‡∏ó‡∏£‡∏®‡∏±‡∏û‡∏ó‡πå) *') || lowerText.startsWith('(‡πÇ‡∏ó‡∏£‡∏®‡∏±‡∏û‡∏ó‡πå)*')) { 
              baseColor = cAction; 
              isAction = true; 
          } 
          else if (lowerText.includes('[info]') || lowerText.includes('description')) { 
              baseColor = cInfo; 
          }
          else if (lowerText.includes('(phone)') || lowerText.includes('[phone]') || lowerText.includes('cellphone') ||
                   lowerText.includes('(‡πÇ‡∏ó‡∏£‡∏®‡∏±‡∏û‡∏ó‡πå)') || lowerText.includes('[‡πÇ‡∏ó‡∏£‡∏®‡∏±‡∏û‡∏ó‡πå]')) { 
              baseColor = cPhone; 
          }
          else if (lowerText.includes('whispers') || lowerText.includes('(low)') || lowerText.includes('‡∏û‡∏π‡∏î‡πÄ‡∏ö‡∏≤') || lowerText.includes('‡∏Å‡∏£‡∏∞‡∏ã‡∏¥‡∏ö')) { 
              baseColor = cWhisper; 
          }
          else if (lowerText.startsWith('$') || lowerText.startsWith('money')) { 
              baseColor = cMoney; 
          }

          const words = text.split(' ');
          let buffer = '';

          for (let i = 0; i < words.length; i++) {
              const testLine = buffer + words[i] + ' ';
              const metrics = this.ctx.measureText(testLine);
              if (metrics.width > wrapWidth && i > 0) {
                  this.drawFragmentedLine(buffer, block.x, currentY, fontSize, baseColor, isAction);
                  maxWidth = Math.max(maxWidth, this.ctx.measureText(buffer).width);
                  buffer = words[i] + ' ';
                  currentY += lineHeight;
              } else { buffer = testLine; }
          }
          this.drawFragmentedLine(buffer, block.x, currentY, fontSize, baseColor, isAction);
          maxWidth = Math.max(maxWidth, this.ctx.measureText(buffer).width);
          currentY += lineHeight;
      });

      block.bounds = {
          x: block.x,
          y: startY,
          w: maxWidth,
          h: currentY - startY
      };

      // Draw Purple Box (UI) - HIDE IF DOWNLOADING
      if (isActive && this.mode === 'move' && !this.isDownloading) {
          this.ctx.strokeStyle = "rgba(155, 89, 182, 0.5)";
          this.ctx.lineWidth = 1;
          this.ctx.strokeRect(block.bounds.x - 5, block.bounds.y - 5, block.bounds.w + 10, block.bounds.h + 10);
      }
    },

    drawFragmentedLine: function(text, x, y, size, baseColor, isAction) {
      const visibleText = text.trimEnd(); 
      if (!visibleText) return;

      const padX = size * 0.1; 
      const topOffset = size * 0.35; 
      const boxHeight = size * 1.7; 

      if (this.els.bg.checked) {
          const w = this.ctx.measureText(visibleText).width;
          this.ctx.fillStyle = "#000000";
          this.ctx.fillRect(x - padX, y - topOffset, w + (padX * 2), boxHeight);
      }

      const words = visibleText.split(' '); 
      let currentX = x;
      const spaceWidth = this.ctx.measureText(" ").width;

      words.forEach((word, idx) => {
         let wordColor = baseColor;
         if (word.includes('$') && !isAction) { wordColor = "#33AA33"; }

         if (this.els.stroke.checked) {
             this.ctx.strokeStyle = 'black';
             this.ctx.lineWidth = size * 0.15; 
             this.ctx.lineJoin = 'round';
             this.ctx.miterLimit = 2;
             this.ctx.strokeText(word, currentX, y);
         }
         this.ctx.fillStyle = wordColor;
         this.ctx.fillText(word, currentX, y);
         currentX += this.ctx.measureText(word).width;
         if (idx < words.length - 1) currentX += spaceWidth;
      });
    },

    // --- Interaction ---
    getMousePos: function(evt) {
      const rect = this.canvas.getBoundingClientRect();
      return { 
        x: (evt.clientX - rect.left) * (this.canvas.width / rect.width), 
        y: (evt.clientY - rect.top) * (this.canvas.height / rect.height) 
      };
    },

    setMode: function(m) {
        this.mode = m;
        this.els.modeBtns.forEach(b => b.classList.remove('active', 'active-censor'));
        if (m === 'move') {
            this.canvas.style.cursor = 'default';
            this.els.modeBtns[0].classList.add('active');
            this.els.censorTools.classList.remove('show-censor');
            this.hoveredCensorIndex = -1;
        } else {
            this.canvas.style.cursor = 'crosshair';
            this.els.modeBtns[1].classList.add('active-censor');
            this.els.censorTools.classList.add('show-censor');
        }
        this.draw();
    },

    resetCurrentPos: function() {
        const sc = this.scenes[this.currentSceneIndex];
        if (sc.imgLoaded) {
          const scale = Math.min(this.canvas.width / sc.img.width, this.canvas.height / sc.img.height);
          sc.imgScale = scale;
          sc.imgX = (this.canvas.width - sc.img.width * scale) / 2;
          sc.imgY = (this.canvas.height - sc.img.height * scale) / 2;
        }
        sc.blocks.forEach((b, i) => {
            b.x = 20; b.y = 20 + (i * 50);
        });
        this.draw();
    },

    setupEvents: function() {
      const self = this;
      
      this.els.text.addEventListener('input', (e) => { 
          const sc = self.scenes[self.currentSceneIndex];
          sc.blocks[sc.activeBlockIndex].text = e.target.value; 
          self.draw(); 
      });
      this.els.size.addEventListener('input', (e) => { self.scenes[self.currentSceneIndex].fontSize = e.target.value; self.draw(); });
      this.els.spacing.addEventListener('input', (e) => { self.scenes[self.currentSceneIndex].lineSpacing = e.target.value; self.draw(); });
      this.els.wrap.addEventListener('input', (e) => { 
          const val = e.target.value;
          self.scenes[self.currentSceneIndex].textWrap = val; 
          self.els.wrapVal.innerText = val + 'px';
          self.draw(); 
      });
      
      // NEW PIXEL SLIDER EVENT
      this.els.pixelSize.addEventListener('input', (e) => {
          const val = parseInt(e.target.value);
          self.scenes[self.currentSceneIndex].pixelSize = val;
          self.els.pixelVal.innerText = val + 'px';
          self.draw();
      });

      this.els.bg.addEventListener('change', () => this.draw());
      this.els.stroke.addEventListener('change', () => this.draw());
      [this.els.width, this.els.height].forEach(el => el.addEventListener('change', () => this.resizeCanvas()));
      
      this.els.upload.addEventListener('change', (e) => {
        if (!e.target.files[0]) return;
        const reader = new FileReader();
        reader.onload = (evt) => {
            const img = new Image();
            img.onload = () => { 
              const sc = self.scenes[self.currentSceneIndex];
              sc.img = img; sc.imgLoaded = true; 
              const scale = Math.min(self.canvas.width / img.width, self.canvas.height / img.height);
              sc.imgScale = scale;
              sc.imgX = (self.canvas.width - img.width * scale) / 2;
              sc.imgY = (self.canvas.height - img.height * scale) / 2;
              self.draw();
            };
            img.src = evt.target.result;
            self.els.upload.value = ''; 
        };
        reader.readAsDataURL(e.target.files[0]);
      });

      this.canvas.addEventListener('mousedown', (e) => {
          const mouse = self.getMousePos(e);
          const sc = self.scenes[self.currentSceneIndex];

          if (e.button === 2 && self.mode === 'censor') { return; }

          if (self.mode === 'censor') {
              if (e.button === 0) { 
                self.isCensoring = true;
                self.censorStart = mouse;
                self.censorCurrent = mouse;
              }
          } else {
              if (e.button === 0) {
                self.isDragging = true;
                self.dragStart = mouse;
                
                let hitBlock = null;
                for (let i = sc.blocks.length - 1; i >= 0; i--) {
                    const b = sc.blocks[i];
                    if (b.bounds && 
                        mouse.x >= b.bounds.x && mouse.x <= b.bounds.x + b.bounds.w &&
                        mouse.y >= b.bounds.y && mouse.y <= b.bounds.y + b.bounds.h) {
                        hitBlock = b;
                        sc.activeBlockIndex = i;
                        self.updateBlockUI();
                        break;
                    }
                }

                if (hitBlock) {
                    self.dragTarget = hitBlock;
                    self.dragOffset = { x: mouse.x - hitBlock.x, y: mouse.y - hitBlock.y };
                } else {
                    self.dragTarget = 'image';
                }
                self.draw();
              }
          }
      });
      
      this.canvas.addEventListener('contextmenu', (e) => {
          if (self.mode === 'censor') {
              e.preventDefault();
              const sc = self.scenes[self.currentSceneIndex];
              if (self.hoveredCensorIndex !== -1) {
                  sc.censoredAreas.splice(self.hoveredCensorIndex, 1);
                  self.hoveredCensorIndex = -1;
                  self.draw();
              }
          }
      });

      window.addEventListener('mouseup', () => { 
          if (self.mode === 'censor' && self.isCensoring) {
              const w = self.censorCurrent.x - self.censorStart.x;
              const h = self.censorCurrent.y - self.censorStart.y;
              if (Math.abs(w) > 5 && Math.abs(h) > 5) {
                  const sc = self.scenes[self.currentSceneIndex];
                  sc.censoredAreas.push({ 
                      x: self.censorStart.x, 
                      y: self.censorStart.y, 
                      w: w, 
                      h: h 
                  });
              }
              self.isCensoring = false;
              self.draw();
          }
          self.isDragging = false; 
          self.dragTarget = null;
      });

      this.canvas.addEventListener('mousemove', (e) => {
          const mouse = self.getMousePos(e);
          const sc = self.scenes[self.currentSceneIndex];
          
          if (self.mode === 'censor') {
             if (self.isCensoring) {
                 self.censorCurrent = mouse;
                 self.draw();
             } 
             else {
                 let foundIndex = -1;
                 for (let i = sc.censoredAreas.length - 1; i >= 0; i--) {
                     const area = sc.censoredAreas[i];
                     const rx = area.w < 0 ? area.x + area.w : area.x;
                     const ry = area.h < 0 ? area.y + area.h : area.y;
                     const rw = Math.abs(area.w);
                     const rh = Math.abs(area.h);
                     
                     if (mouse.x >= rx && mouse.x <= rx + rw &&
                         mouse.y >= ry && mouse.y <= ry + rh) {
                         foundIndex = i;
                         break;
                     }
                 }
                 if (foundIndex !== self.hoveredCensorIndex) {
                     self.hoveredCensorIndex = foundIndex;
                     self.draw(); 
                 }
             }

          } else {
             if (!self.isDragging) return;
             
             if (self.dragTarget === 'image') {
                 const dx = mouse.x - self.dragStart.x;
                 const dy = mouse.y - self.dragStart.y;
                 sc.imgX += dx;
                 sc.imgY += dy;
                 self.dragStart = mouse; 
             } else if (self.dragTarget) {
                 // Boundary Logic
                 let newX = mouse.x - self.dragOffset.x;
                 let newY = mouse.y - self.dragOffset.y;

                 const bw = self.dragTarget.bounds ? self.dragTarget.bounds.w : 0;
                 const bh = self.dragTarget.bounds ? self.dragTarget.bounds.h : 0;
                 
                 if (newX < 0) newX = 0;
                 if (newX + bw > self.canvas.width) newX = self.canvas.width - bw;
                 
                 if (newY < 0) newY = 0;
                 if (newY + bh > self.canvas.height) newY = self.canvas.height - bh;

                 self.dragTarget.x = newX;
                 self.dragTarget.y = newY;
             }
             self.draw();
          }
      });

      this.canvas.addEventListener('wheel', (e) => {
          const sc = self.scenes[self.currentSceneIndex];
          if (self.mode === 'move' && sc.imgLoaded) {
             e.preventDefault();
             const zoomIntensity = 0.1;
             const delta = e.deltaY < 0 ? 1 + zoomIntensity : 1 - zoomIntensity;
             sc.imgScale = Math.min(Math.max(0.1, sc.imgScale * delta), 10);
             self.draw();
          }
      });
    },

    downloadCurrentScene: function() {
        this.isDownloading = true;
        this.draw(); 
        
        this.canvas.toBlob((blob) => {
            if(blob) {
                saveAs(blob, `GTA-Log-Scene-${this.currentSceneIndex + 1}.png`);
            }
            this.isDownloading = false;
            this.draw();
        }, 'image/png');
    },

    downloadAllScenes: async function() {
      const zip = new JSZip();
      const folder = zip.folder("GTA_Logs");
      this.els.downloadBtn.innerText = "‚è≥ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•...";
      this.els.downloadBtn.classList.add('loading');
      
      const originalIndex = this.currentSceneIndex;
      this.isDownloading = true; 

      try {
          for (let i = 0; i < this.scenes.length; i++) {
              this.switchScene(i);
              await new Promise(r => setTimeout(r, 50));
              const blob = await new Promise(resolve => this.canvas.toBlob(resolve, 'image/png'));
              folder.file(`scene-${i+1}.png`, blob);
          }
          const content = await zip.generateAsync({type:"blob"});
          saveAs(content, "RP-Logs-Pack.zip");
      } catch (err) { console.error(err); alert("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î"); } 
      finally { 
          this.isDownloading = false; 
          this.switchScene(originalIndex); 
          this.els.downloadBtn.innerText = "üì¶ ZIP (‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î)"; 
          this.els.downloadBtn.classList.remove('loading'); 
      }
    }
  };

  window.addEventListener('DOMContentLoaded', () => { app.init(); });
</script>
</body>
</html>
