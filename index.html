<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>GTA-RP Screenshot Buddy (Overlay System)</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">

<style>
  /* --- Luxury Variables --- */
  :root {
    --bg-main: #050505;
    --bg-sidebar: #0f0f0f;
    --border-color: #222;
    --accent: #c5a059;
    --accent-dim: #8a703d;
    --text-main: #eaeaea;
    --text-muted: #888;
    --input-bg: #161616;
    --radius: 8px;
  }

  body { 
    font-family: 'Inter', sans-serif; 
    background: var(--bg-main); 
    color: var(--text-main); 
    margin: 0; padding: 0; 
    height: 100vh; 
    display: flex; 
    overflow: hidden; 
  }

  .app-layout { display: flex; width: 100%; height: 100%; }

  /* --- Stage --- */
  .stage-area {
    flex: 1; position: relative; display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    background: radial-gradient(circle at center, #1a1a1a 0%, #050505 100%);
    overflow: hidden;
  }
  .canvas-wrapper {
    box-shadow: 0 20px 60px rgba(0,0,0,0.8); border: 1px solid #222;
    line-height: 0; max-width: 90%; max-height: 85vh;
  }
  canvas { display: block; background: #000; max-width: 100%; height: auto; }

  /* Scene Bar */
  .scene-bar-wrapper {
    position: absolute; bottom: 20px;
    background: rgba(15, 15, 15, 0.8); backdrop-filter: blur(10px);
    border: 1px solid rgba(255,255,255,0.05); padding: 10px 20px; border-radius: 50px;
    display: flex; gap: 10px; max-width: 90%; overflow-x: auto; scrollbar-width: none;
  }
  .scene-btn {
    background: transparent; color: var(--text-muted); border: 1px solid transparent;
    padding: 6px 14px; border-radius: 20px; font-size: 12px; cursor: pointer;
    transition: 0.3s; white-space: nowrap; display: flex; align-items: center; gap: 8px;
    user-select: none;
  }
  .scene-btn:hover { color: #fff; background: rgba(255,255,255,0.05); }
  .scene-btn.active { 
    background: var(--accent); color: #000; font-weight: 600; 
    box-shadow: 0 0 15px rgba(197, 160, 89, 0.3);
  }
  .scene-close {
    font-size: 14px; width: 18px; height: 18px; display: flex; align-items: center; justify-content: center;
    border-radius: 50%; transition: 0.2s; color: #555; font-weight: bold; background: rgba(0,0,0,0.1); margin-left: 5px;
  }
  .scene-close:hover { background: #e74c3c; color: #fff; transform: scale(1.1); }
  .scene-add-btn {
    width: 30px; height: 30px; border-radius: 50%; background: #222; border: none; color: #fff;
    cursor: pointer; transition: 0.2s; display: flex; align-items: center; justify-content: center;
  }
  .scene-add-btn:hover { background: var(--accent); color: #000; }

  /* --- Sidebar --- */
  .sidebar {
    width: 360px; background: var(--bg-sidebar); border-left: 1px solid var(--border-color);
    display: flex; flex-direction: column; overflow-y: auto;
    scrollbar-width: thin; scrollbar-color: #333 #111;
  }
  .sidebar-header {
    padding: 20px 25px; border-bottom: 1px solid var(--border-color);
    display: flex; justify-content: space-between; align-items: center;
  }
  .brand-title { 
    margin: 0; font-size: 16px; font-weight: 600; letter-spacing: 0.5px;
    background: linear-gradient(45deg, #fff, #888); -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  }
  .lang-switch { display: flex; background: #1a1a1a; border-radius: 4px; padding: 2px; }
  .lang-btn {
    background: transparent; border: none; color: #555; font-size: 10px; font-weight: bold;
    padding: 4px 8px; cursor: pointer; border-radius: 4px; transition: 0.2s;
  }
  .lang-btn.active { background: var(--accent); color: #000; }

  .control-group { padding: 20px 25px; border-bottom: 1px solid rgba(255,255,255,0.03); }
  .group-title {
    font-size: 11px; text-transform: uppercase; letter-spacing: 1.2px;
    color: var(--text-muted); margin-bottom: 15px; font-weight: 600;
  }

  label { display: block; font-size: 12px; color: #aaa; margin-bottom: 6px; }
  input[type="text"], input[type="number"], textarea {
    width: 100%; background: var(--input-bg); border: 1px solid transparent; color: #fff;
    padding: 10px 12px; border-radius: var(--radius); font-family: inherit; font-size: 13px;
    box-sizing: border-box; transition: 0.2s;
  }
  input:focus, textarea:focus { outline: none; border-color: var(--accent-dim); background: #1a1a1a; }
  textarea { min-height: 100px; resize: vertical; line-height: 1.5; }
  
  input[type="range"] {
    width: 100%; height: 4px; background: #333; border-radius: 2px; outline: none; -webkit-appearance: none; margin: 10px 0;
  }
  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none; width: 14px; height: 14px; background: var(--accent);
    border-radius: 50%; cursor: pointer; transition: 0.2s;
  }

  .mode-switcher { display: flex; background: #1a1a1a; padding: 4px; border-radius: 8px; margin-bottom: 15px; }
  .mode-btn {
    flex: 1; border: none; background: transparent; color: #666;
    padding: 8px; font-size: 12px; font-weight: 600; cursor: pointer; border-radius: 6px; transition: 0.3s;
  }
  .mode-btn.active { background: #2a2a2a; color: #fff; }
  .mode-btn.active-censor { background: var(--accent); color: #000; }

  .btn-primary {
    width: 100%; background: linear-gradient(135deg, var(--accent), var(--accent-dim));
    color: #000; border: none; padding: 12px; border-radius: var(--radius);
    font-weight: 600; cursor: pointer; font-size: 13px; margin-top: 10px;
    box-shadow: 0 4px 15px rgba(197, 160, 89, 0.2); transition: 0.2s;
  }
  .btn-primary:hover { transform: translateY(-1px); box-shadow: 0 6px 20px rgba(197, 160, 89, 0.3); }

  .btn-secondary {
    width: 100%; background: #222; color: #ccc; border: 1px solid #333;
    padding: 10px; border-radius: var(--radius); font-size: 12px; cursor: pointer;
    transition: 0.2s; margin-top: 5px;
  }
  .btn-secondary:hover { background: #333; color: #fff; border-color: #444; }

  .btn-icon-group { display: flex; gap: 5px; margin-bottom: 10px; }
  .btn-icon {
    flex: 1; background: #222; border: none; color: #ccc; padding: 6px; border-radius: 4px; font-size: 14px; cursor: pointer;
  }
  .btn-icon:hover { background: #333; color: #fff; }
  .btn-danger { color: #e74c3c; }

  .row { display: flex; gap: 10px; align-items: center; } .col { flex: 1; }
  .checkbox-wrapper { display: flex; align-items: center; gap: 10px; margin-top: 10px; }
  .checkbox-wrapper label { margin: 0; cursor: pointer; user-select: none; font-size: 12px; }
  input[type="checkbox"] { accent-color: var(--accent); width: 14px; height: 14px; cursor: pointer; }

  .file-upload-styled { position: relative; overflow: hidden; display: inline-block; width: 100%; }
  .file-upload-styled input[type=file] { font-size: 100px; position: absolute; left: 0; top: 0; opacity: 0; cursor: pointer; }
  .file-btn-fake {
    background: #1a1a1a; border: 1px dashed #444; color: #888; padding: 12px;
    text-align: center; border-radius: var(--radius); font-size: 12px; transition: 0.2s;
  }
  .file-upload-styled:hover .file-btn-fake { border-color: var(--accent); color: var(--accent); }
  
  .helper-status { font-size: 10px; color: #444; text-align: center; margin-top: 15px; opacity: 0.4; pointer-events: none; }
</style>
</head>
<body>

<div class="app-layout">
  <div class="stage-area">
    <div class="canvas-wrapper">
      <canvas id="canvas" width="800" height="600"></canvas>
    </div>
    <div class="scene-bar-wrapper">
      <div id="sceneContainer" style="display:flex; gap:10px;"></div>
      <button class="scene-add-btn" id="addSceneBtn" title="New Scene">+</button>
    </div>
  </div>

  <div class="sidebar">
    <div class="sidebar-header">
      <h1 class="brand-title">GTA-RP Screenshot Buddy</h1>
      <div class="lang-switch">
        <button class="lang-btn" id="langTH">TH</button>
        <button class="lang-btn active" id="langEN">EN</button>
      </div>
    </div>

    <div class="control-group">
      <div class="group-title" data-t="txt_title">Text Editor</div>
      <div class="row" style="margin-bottom:8px; justify-content:space-between;">
         <span style="font-size:11px; color:var(--accent);" id="activeBlockLabel">Block #1</span>
         <div class="btn-icon-group" style="margin:0; width:auto;">
           <button class="btn-icon" id="btnPrevBlock">â—€</button>
           <button class="btn-icon" id="btnNextBlock">â–¶</button>
           <button class="btn-icon" id="btnAddBlock" style="color:var(--accent);">+</button>
           <button class="btn-icon btn-danger" id="btnDelBlock">Ã—</button>
         </div>
      </div>
      <textarea id="textInput" data-t-ph="ph_text"></textarea>
    </div>

    <div class="control-group">
      <div class="group-title" data-t="overlay_title">Overlay & Watermark</div>
      <div class="file-upload-styled">
         <div class="file-btn-fake" data-t="btn_add_overlay">âž• Add Image / Logo</div>
         <input type="file" id="uploadOverlay" accept="image/*">
      </div>
      
      <div id="overlayControls" style="display:none; margin-top:15px; background:#161616; padding:10px; border-radius:8px;">
        <div style="font-size:11px; color:var(--accent); margin-bottom:5px;">Editing Selected Image</div>
        <label><span data-t="lbl_opacity">Opacity</span> <span id="ovOpacityVal" style="float:right">100%</span></label>
        <input type="range" id="ovOpacity" min="0" max="100" value="100">
        
        <label><span data-t="lbl_scale">Scale</span> <span id="ovScaleVal" style="float:right">1.0x</span></label>
        <input type="range" id="ovScale" min="10" max="300" value="100">

        <button class="btn-secondary btn-danger" id="btnDelOverlay" data-t="btn_del_overlay">Remove Image</button>
      </div>
      <div id="overlayHint" style="font-size:11px; color:#555; margin-top:10px; text-align:center;">
        <span data-t="hint_overlay">Click on an added image to edit</span>
      </div>
    </div>

    <div class="control-group">
      <div class="group-title" data-t="tool_title">Tools & Mode</div>
      <div class="mode-switcher">
        <button class="mode-btn active" id="modeMove" data-t="btn_move">Move / Edit</button>
        <button class="mode-btn" id="modeCensor" data-t="btn_censor">Censor / Blur</button>
      </div>
      <div id="censorTools" style="display:none; flex-direction:column; gap:10px;">
        <div class="row">
           <div class="col"><label data-t="lbl_pixel">Pixel Size</label><input type="range" id="pixelSize" min="2" max="40" value="10"></div>
        </div>
        <div class="row">
          <button class="btn-secondary" id="btnUndo">Undo</button>
          <button class="btn-secondary btn-danger" id="btnClearCensor">Clear</button>
        </div>
      </div>
    </div>

    <div class="control-group">
      <div class="group-title" data-t="style_title">Typography & Style</div>
      <div class="row">
        <div class="col"><label data-t="lbl_font">Font Size</label><input type="number" id="fontSize" value="13"></div>
        <div class="col"><label data-t="lbl_spacing">Line Spacing</label><input type="number" id="lineSpacing" value="8"></div>
      </div>
      <div style="margin-top:10px;">
        <label><span data-t="lbl_wrap">Max Text Width</span></label>
        <input type="range" id="textWrapWidth" min="200" max="2000" value="800" step="10">
      </div>
      <div class="checkbox-wrapper">
        <label><input type="checkbox" id="showBg" checked> <span data-t="chk_bg">Black BG</span></label>
        <label><input type="checkbox" id="showStroke" checked> <span data-t="chk_stroke">Stroke</span></label>
      </div>
    </div>

    <div class="control-group">
      <div class="group-title" data-t="img_title">Background Image</div>
      <div class="file-upload-styled">
         <div class="file-btn-fake" data-t="btn_upload">ðŸ“‚ Change Background</div>
         <input type="file" id="upload" accept="image/*">
      </div>
      <div class="row" style="margin-top:10px;">
        <div class="col"><label>W</label><input type="number" id="cWidth" value="800"></div>
        <div class="col"><label>H</label><input type="number" id="cHeight" value="600"></div>
      </div>
      <button class="btn-secondary" id="btnCenter" data-t="btn_center">Recenter BG</button>
    </div>

    <div class="control-group" style="border-bottom:none;">
       <div class="group-title" data-t="export_title">Export</div>
       <button class="btn-primary" id="btnDlPng" data-t="dl_png">Download (PNG)</button>
       <button class="btn-secondary" id="downloadBtn" data-t="dl_zip">Download All (ZIP)</button>
    </div>
  </div>
</div>

<script>
  const i18n = {
    th: {
      txt_title: "à¹à¸à¹‰à¹„à¸‚à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡", ph_text: "à¹ƒà¸ªà¹ˆà¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡ Log à¸—à¸µà¹ˆà¸™à¸µà¹ˆ...\nJohn says: à¸ªà¸§à¸±à¸ªà¸”à¸µ\n(Phone): à¸®à¸±à¸¥à¹‚à¸«à¸¥\n* John à¹‚à¸šà¸à¸¡à¸·à¸­\n(Phone) * John à¸«à¸±à¸§à¹€à¸£à¸²à¸°",
      tool_title: "à¹€à¸„à¸£à¸·à¹ˆà¸­à¸‡à¸¡à¸·à¸­", btn_move: "à¸‚à¸¢à¸±à¸š / à¹à¸à¹‰à¹„à¸‚", btn_censor: "à¹€à¸‹à¹‡à¸™à¹€à¸‹à¸­à¸£à¹Œ / à¹€à¸šà¸¥à¸­",
      overlay_title: "à¸£à¸¹à¸›à¸‹à¹‰à¸­à¸™ / à¹‚à¸¥à¹‚à¸à¹‰", btn_add_overlay: "âž• à¹€à¸žà¸´à¹ˆà¸¡à¸£à¸¹à¸› / à¹‚à¸¥à¹‚à¸à¹‰", 
      lbl_opacity: "à¸„à¸§à¸²à¸¡à¹‚à¸›à¸£à¹ˆà¸‡à¹ƒà¸ª", lbl_scale: "à¸‚à¸™à¸²à¸”", btn_del_overlay: "à¸¥à¸šà¸£à¸¹à¸›à¸™à¸µà¹‰à¸­à¸­à¸", hint_overlay: "à¸„à¸¥à¸´à¸à¸—à¸µà¹ˆà¸£à¸¹à¸›à¸šà¸™à¸ˆà¸­à¹€à¸žà¸·à¹ˆà¸­à¹à¸à¹‰à¹„à¸‚",
      lbl_pixel: "à¸„à¸§à¸²à¸¡à¸¥à¸°à¹€à¸­à¸µà¸¢à¸”", style_title: "à¸£à¸¹à¸›à¹à¸šà¸š", lbl_font: "à¸‚à¸™à¸²à¸”à¸Ÿà¸­à¸™à¸•à¹Œ", lbl_spacing: "à¸£à¸°à¸¢à¸°à¸«à¹ˆà¸²à¸‡",
      lbl_wrap: "à¸„à¸§à¸²à¸¡à¸à¸§à¹‰à¸²à¸‡à¸ªà¸¹à¸‡à¸ªà¸¸à¸”", chk_bg: "à¸žà¸·à¹‰à¸™à¸«à¸¥à¸±à¸‡à¸”à¸³", chk_stroke: "à¸‚à¸­à¸šà¸•à¸±à¸§à¸«à¸™à¸±à¸‡à¸ªà¸·à¸­",
      img_title: "à¸£à¸¹à¸›à¸žà¸·à¹‰à¸™à¸«à¸¥à¸±à¸‡", btn_upload: "ðŸ“‚ à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¸žà¸·à¹‰à¸™à¸«à¸¥à¸±à¸‡", btn_center: "à¸ˆà¸±à¸”à¸à¸¶à¹ˆà¸‡à¸à¸¥à¸²à¸‡",
      export_title: "à¸šà¸±à¸™à¸—à¸¶à¸", dl_png: "à¸šà¸±à¸™à¸—à¸¶à¸à¸£à¸¹à¸›à¸™à¸µà¹‰ (PNG)", dl_zip: "à¸šà¸±à¸™à¸—à¸¶à¸à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸” (ZIP)", block_label: "à¸à¸¥à¹ˆà¸­à¸‡à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡"
    },
    en: {
      txt_title: "Text Editor", ph_text: "Enter Log here...\nJohn says: Hello\n(Phone): Hi\n* John waves\n(Phone) * John laughs",
      tool_title: "Tools", btn_move: "Move / Edit", btn_censor: "Censor / Blur",
      overlay_title: "Overlay / Watermark", btn_add_overlay: "âž• Add Image / Logo", 
      lbl_opacity: "Opacity", lbl_scale: "Scale", btn_del_overlay: "Remove Image", hint_overlay: "Click image on canvas to edit",
      lbl_pixel: "Pixel Size", style_title: "Typography", lbl_font: "Font Size", lbl_spacing: "Line Spacing",
      lbl_wrap: "Max Width", chk_bg: "Black BG", chk_stroke: "Stroke",
      img_title: "Background", btn_upload: "ðŸ“‚ Change BG", btn_center: "Recenter BG",
      export_title: "Export", dl_png: "Download (PNG)", dl_zip: "Download All (ZIP)", block_label: "Block"
    }
  };

  window.app = {
    canvas: null, ctx: null, els: {}, scenes: [], currentSceneIndex: 0,
    isDragging: false, dragTarget: null, dragStart: { x: 0, y: 0 },
    mode: 'move', isCensoring: false, censorStart: { x: 0, y: 0 }, censorCurrent: { x: 0, y: 0 }, hoveredCensorIndex: -1,
    isDownloading: false, currentLang: 'en',

    init: function() {
      this.canvas = document.getElementById('canvas');
      this.ctx = this.canvas.getContext('2d');
      const $ = (id) => document.getElementById(id);
      this.els = {
        text: $('textInput'), size: $('fontSize'), spacing: $('lineSpacing'),
        wrap: $('textWrapWidth'), width: $('cWidth'), height: $('cHeight'),
        bg: $('showBg'), stroke: $('showStroke'), upload: $('upload'),
        sceneContainer: $('sceneContainer'), downloadBtn: $('downloadBtn'),
        blockLabel: $('activeBlockLabel'), censorTools: $('censorTools'),
        pixelSize: $('pixelSize'), modeBtns: { move: $('modeMove'), censor: $('modeCensor') },
        langBtns: { th: $('langTH'), en: $('langEN') },
        // Overlay els
        uploadOverlay: $('uploadOverlay'), overlayControls: $('overlayControls'),
        ovOpacity: $('ovOpacity'), ovOpacityVal: $('ovOpacityVal'),
        ovScale: $('ovScale'), ovScaleVal: $('ovScaleVal'),
        btnDelOverlay: $('btnDelOverlay'), overlayHint: $('overlayHint')
      };
      
      this.addNewScene(true);
      this.setupDOMEvents();
      this.resizeCanvas();
      this.setLang('th');
    },

    setLang: function(lang) {
      this.currentLang = lang;
      this.els.langBtns.th.classList.toggle('active', lang === 'th');
      this.els.langBtns.en.classList.toggle('active', lang === 'en');
      const dict = i18n[lang];
      document.querySelectorAll('[data-t]').forEach(el => {
        const key = el.getAttribute('data-t'); if (dict[key]) el.innerText = dict[key];
      });
      document.querySelectorAll('[data-t-ph]').forEach(el => {
        const key = el.getAttribute('data-t-ph'); if (dict[key]) el.placeholder = dict[key];
      });
      this.updateBlockUI();
    },

    Scene: class {
      constructor(copyFrom = null) {
        this.img = copyFrom ? copyFrom.img : null;
        this.imgLoaded = copyFrom ? copyFrom.imgLoaded : false;
        this.imgX = copyFrom ? copyFrom.imgX : 0;
        this.imgY = copyFrom ? copyFrom.imgY : 0;
        this.imgScale = copyFrom ? copyFrom.imgScale : 1;
        this.censoredAreas = copyFrom ? JSON.parse(JSON.stringify(copyFrom.censoredAreas)) : [];
        
        // Overlays array
        this.overlays = copyFrom ? copyFrom.overlays.map(o => ({...o})) : [];
        this.activeOverlayIndex = -1;

        if (copyFrom) {
            this.blocks = copyFrom.blocks.map(b => ({...b}));
            this.activeBlockIndex = copyFrom.activeBlockIndex;
        } else {
            this.blocks = [{ text: "", x: 20, y: 20, width: 800, height: 0, bounds: null }];
            this.activeBlockIndex = 0;
        }
        this.fontSize = copyFrom ? copyFrom.fontSize : 13;
        this.lineSpacing = copyFrom ? copyFrom.lineSpacing : 8;
        this.textWrap = copyFrom ? copyFrom.textWrap : 800;
        this.pixelSize = copyFrom ? copyFrom.pixelSize : 10;
      }
    },

    addNewScene: function(isFirst = false) {
      const prevScene = !isFirst && this.scenes[this.currentSceneIndex] ? this.scenes[this.currentSceneIndex] : null;
      this.scenes.push(new this.Scene(prevScene));
      this.switchScene(this.scenes.length - 1);
    },

    deleteScene: function(index) {
      if (this.scenes.length <= 1) { alert("Requires at least 1 scene."); return; }
      if (confirm("Delete Scene?")) {
        this.scenes.splice(index, 1);
        if (index === this.currentSceneIndex) this.currentSceneIndex = Math.max(0, index - 1);
        else if (index < this.currentSceneIndex) this.currentSceneIndex--; 
        if (this.currentSceneIndex >= this.scenes.length) this.currentSceneIndex = this.scenes.length - 1;
        this.switchScene(this.currentSceneIndex);
      }
    },

    switchScene: function(index) {
      this.currentSceneIndex = index;
      const sc = this.scenes[index];
      this.updateBlockUI();
      this.els.size.value = sc.fontSize;
      this.els.spacing.value = sc.lineSpacing;
      this.els.wrap.value = sc.textWrap;
      this.els.pixelSize.value = sc.pixelSize;
      
      this.updateOverlayUI();
      this.updateSceneUI();
      this.draw();
    },

    updateSceneUI: function() {
      const container = this.els.sceneContainer; container.innerHTML = ''; 
      this.scenes.forEach((_, idx) => {
        const btn = document.createElement('div');
        btn.className = `scene-btn ${idx === this.currentSceneIndex ? 'active' : ''}`;
        btn.innerHTML = `<span>Scene ${idx + 1}</span><span class="scene-close">Ã—</span>`;
        btn.querySelector('.scene-close').onclick = (e) => { e.stopPropagation(); this.deleteScene(idx); };
        btn.onclick = () => this.switchScene(idx);
        container.appendChild(btn);
      });
    },

    // --- Overlay Logic ---
    addOverlay: function(img) {
      const sc = this.scenes[this.currentSceneIndex];
      // Default to center
      const x = (this.canvas.width - 150) / 2;
      const y = (this.canvas.height - 150) / 2;
      sc.overlays.push({ 
         img: img, x: x, y: y, w: 150, h: 150 * (img.height/img.width), 
         opacity: 1.0, scalePercent: 100, originalW: 150, originalH: 150 * (img.height/img.width)
      });
      sc.activeOverlayIndex = sc.overlays.length - 1;
      this.updateOverlayUI();
      this.draw();
    },
    updateOverlayUI: function() {
       const sc = this.scenes[this.currentSceneIndex];
       if (sc.activeOverlayIndex >= 0 && sc.overlays[sc.activeOverlayIndex]) {
           const ov = sc.overlays[sc.activeOverlayIndex];
           this.els.overlayControls.style.display = 'block';
           this.els.overlayHint.style.display = 'none';
           this.els.ovOpacity.value = ov.opacity * 100;
           this.els.ovOpacityVal.innerText = Math.round(ov.opacity * 100) + '%';
           this.els.ovScale.value = ov.scalePercent;
           this.els.ovScaleVal.innerText = ov.scalePercent / 100 + 'x';
       } else {
           this.els.overlayControls.style.display = 'none';
           this.els.overlayHint.style.display = 'block';
       }
    },
    deleteActiveOverlay: function() {
       const sc = this.scenes[this.currentSceneIndex];
       if (sc.activeOverlayIndex >= 0) {
           sc.overlays.splice(sc.activeOverlayIndex, 1);
           sc.activeOverlayIndex = -1;
           this.updateOverlayUI(); this.draw();
       }
    },

    // --- Block Logic ---
    addTextBlock: function() {
        const sc = this.scenes[this.currentSceneIndex];
        sc.blocks.push({ text: "...", x: 50, y: 50, width: 800, height: 0, bounds: null });
        sc.activeBlockIndex = sc.blocks.length - 1;
        this.updateBlockUI(); this.draw();
    },
    deleteTextBlock: function() {
        const sc = this.scenes[this.currentSceneIndex];
        if (sc.blocks.length <= 1) return;
        sc.blocks.splice(sc.activeBlockIndex, 1);
        sc.activeBlockIndex = Math.max(0, sc.activeBlockIndex - 1);
        this.updateBlockUI(); this.draw();
    },
    cycleBlock: function(dir) {
        const sc = this.scenes[this.currentSceneIndex];
        let newIdx = sc.activeBlockIndex + dir;
        if (newIdx < 0) newIdx = sc.blocks.length - 1;
        if (newIdx >= sc.blocks.length) newIdx = 0;
        sc.activeBlockIndex = newIdx;
        this.updateBlockUI(); this.draw(); 
    },
    updateBlockUI: function() {
        if(!this.scenes[this.currentSceneIndex]) return;
        const sc = this.scenes[this.currentSceneIndex];
        const block = sc.blocks[sc.activeBlockIndex];
        if(block) {
            this.els.text.value = block.text;
            this.els.blockLabel.innerText = `${i18n[this.currentLang].block_label} #${sc.activeBlockIndex + 1}`;
        }
    },

    resizeCanvas: function() {
      this.canvas.width = parseInt(this.els.width.value) || 800;
      this.canvas.height = parseInt(this.els.height.value) || 600;
      this.draw();
    },

    draw: function() {
      const sc = this.scenes[this.currentSceneIndex];
      if (!sc) return;
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      
      // 1. BG Layer
      if (sc.imgLoaded && sc.img) {
        this.ctx.drawImage(sc.img, sc.imgX, sc.imgY, sc.img.width * sc.imgScale, sc.img.height * sc.imgScale);
      } else {
        this.ctx.fillStyle = "#111"; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = "#333"; this.ctx.font = "20px sans-serif"; this.ctx.textAlign = "center";
        this.ctx.fillText(`Scene ${this.currentSceneIndex + 1}`, this.canvas.width/2, this.canvas.height/2);
      }

      // 2. Overlay Layer
      sc.overlays.forEach((ov, idx) => {
          this.ctx.save();
          this.ctx.globalAlpha = ov.opacity;
          this.ctx.drawImage(ov.img, ov.x, ov.y, ov.w, ov.h);
          this.ctx.restore();
          
          // Draw selection border if active and not downloading
          if (!this.isDownloading && idx === sc.activeOverlayIndex && this.mode === 'move') {
              this.ctx.strokeStyle = '#f1c40f'; this.ctx.lineWidth = 2;
              this.ctx.strokeRect(ov.x, ov.y, ov.w, ov.h);
              // Small handle
              this.ctx.fillStyle = '#f1c40f';
              this.ctx.fillRect(ov.x + ov.w - 5, ov.y + ov.h - 5, 10, 10);
          }
      });

      // 3. Text Layer
      sc.blocks.forEach((block) => { this.drawTextBlock(sc, block); });

      // 4. Censor Layer
      if (sc.censoredAreas.length > 0) {
          sc.censoredAreas.forEach(area => this.pixelateArea(area.x, area.y, area.w, area.h));
      }

      // 5. UI Helpers
      if (!this.isDownloading) {
          if (this.mode === 'move') {
              const activeBlock = sc.blocks[sc.activeBlockIndex];
              if (activeBlock && activeBlock.bounds) {
                   this.ctx.strokeStyle = "rgba(197, 160, 89, 0.8)"; 
                   this.ctx.lineWidth = 1; 
                   this.ctx.strokeRect(activeBlock.bounds.x, activeBlock.bounds.y, activeBlock.bounds.w, activeBlock.bounds.h);
              }
          }
          if (this.mode === 'censor') {
             // ... Censor UI (Red dashed box) ...
             if (this.hoveredCensorIndex !== -1 && sc.censoredAreas[this.hoveredCensorIndex]) {
                  const area = sc.censoredAreas[this.hoveredCensorIndex];
                  this.ctx.strokeStyle = "#c0392b"; this.ctx.lineWidth = 2;
                  this.ctx.setLineDash([5, 3]); this.ctx.strokeRect(area.x, area.y, area.w, area.h); this.ctx.setLineDash([]);
              }
              if (this.isCensoring) {
                  const w = this.censorCurrent.x - this.censorStart.x;
                  const h = this.censorCurrent.y - this.censorStart.y;
                  this.ctx.fillStyle = "rgba(255, 255, 255, 0.2)"; this.ctx.fillRect(this.censorStart.x, this.censorStart.y, w, h);
                  this.ctx.strokeStyle = "#e67e22"; this.ctx.lineWidth = 2; this.ctx.strokeRect(this.censorStart.x, this.censorStart.y, w, h);
              }
          }
      }
    },

    pixelateArea: function(x, y, w, h) {
        if (w === 0 || h === 0) return;
        const sc = this.scenes[this.currentSceneIndex];
        const sampleSize = sc.pixelSize || 10;
        const tempCanvas = document.createElement('canvas'); const tempCtx = tempCanvas.getContext('2d');
        const rx = Math.floor(w < 0 ? x + w : x); const ry = Math.floor(h < 0 ? y + h : y);
        const rw = Math.abs(w); const rh = Math.abs(h);
        if (rw < 1 || rh < 1) return;
        tempCanvas.width = rw; tempCanvas.height = rh;
        tempCtx.drawImage(this.canvas, rx, ry, rw, rh, 0, 0, rw, rh);
        const sw = Math.max(1, Math.floor(rw / sampleSize)); const sh = Math.max(1, Math.floor(rh / sampleSize));
        this.ctx.imageSmoothingEnabled = false;
        this.ctx.drawImage(tempCanvas, 0, 0, rw, rh, rx, ry, sw, sh);
        this.ctx.drawImage(this.canvas, rx, ry, sw, sh, rx, ry, rw, rh);
        this.ctx.imageSmoothingEnabled = true;
    },

    drawTextBlock: function(scene, block) {
      if (!block.text) { block.bounds = null; return; }
      const fontSize = parseInt(this.els.size.value) || 13;
      const spacing = parseInt(this.els.spacing.value) || 8;
      const wrapWidth = parseInt(this.els.wrap.value) || 800;
      const lineHeight = fontSize + spacing; 
      
      const cAction = "#C2A2DA"; const cNormal = "#FFFFFF"; const cWhisper = "#BDBDBD"; 
      const cPhone = "#FFFF00"; const cMoney = "#33AA33";  

      this.ctx.font = `600 ${fontSize}px sans-serif`;
      this.ctx.textBaseline = "top"; this.ctx.textAlign = "left";

      const lines = block.text.split('\n');
      let currentY = block.y; let maxContentWidth = 0; 
      const padX = fontSize * 0.1; const topOffset = fontSize * 0.35; const boxHeight = fontSize * 1.7; 
      const startY = currentY;

      lines.forEach(line => {
          let text = line.trim(); let lowerText = text.toLowerCase();
          let baseColor = cNormal; let isAction = false; 

          const isPhoneAction = /^[(\[]\s*(phone|cellphone|à¹‚à¸—à¸£à¸¨à¸±à¸žà¸—à¹Œ)\s*[)\]]\s*\*/i.test(text);

          if (text.startsWith('*') || text.startsWith('>') || lowerText.startsWith('me ') || isPhoneAction) { 
              baseColor = cAction; isAction = true; 
          } 
          else if (lowerText.includes('(phone)') || lowerText.includes('[phone]') || lowerText.includes('cellphone') || lowerText.includes('(à¹‚à¸—à¸£à¸¨à¸±à¸žà¸—à¹Œ)')) {
             baseColor = cPhone;
          } 
          else if (lowerText.includes('whispers') || lowerText.includes('(low)') || lowerText.includes('à¸žà¸¹à¸”à¹€à¸šà¸²')) { 
              baseColor = cWhisper; 
          } 
          else if (lowerText.startsWith('$') || lowerText.startsWith('money')) { 
             baseColor = cMoney; 
          }

          const words = text.split(' '); let buffer = '';
          for (let i = 0; i < words.length; i++) {
              const testLine = buffer + words[i] + ' ';
              if (this.ctx.measureText(testLine).width > wrapWidth && i > 0) {
                  const lineW = this.drawFragmentedLine(buffer, block.x, currentY, fontSize, baseColor, isAction, padX, topOffset, boxHeight);
                  if(lineW > maxContentWidth) maxContentWidth = lineW;
                  buffer = words[i] + ' '; currentY += lineHeight;
              } else { buffer = testLine; }
          }
          const lineW = this.drawFragmentedLine(buffer, block.x, currentY, fontSize, baseColor, isAction, padX, topOffset, boxHeight);
          if(lineW > maxContentWidth) maxContentWidth = lineW;
          currentY += lineHeight;
      });

      block.bounds = { 
          x: block.x - padX, y: startY - topOffset, 
          w: maxContentWidth + (padX * 2), h: currentY - startY 
      };
    },

    drawFragmentedLine: function(text, x, y, size, baseColor, isAction, padX, topOffset, boxHeight) {
      const visibleText = text.trimEnd(); if (!visibleText) return 0;
      const totalWidth = this.ctx.measureText(visibleText).width;
      if (this.els.bg.checked) {
          this.ctx.fillStyle = "#000000"; 
          this.ctx.fillRect(x - padX, y - topOffset, totalWidth + (padX * 2), boxHeight);
      }
      const words = visibleText.split(' '); let currentX = x; const spaceWidth = this.ctx.measureText(" ").width;
      words.forEach((word, idx) => {
         let wordColor = baseColor; 
         if (word.includes('$') && !isAction && baseColor !== "#FFFF00") { wordColor = "#33AA33"; }
         if (this.els.stroke.checked) {
             this.ctx.strokeStyle = 'black'; this.ctx.lineWidth = size * 0.15; 
             this.ctx.lineJoin = 'round'; this.ctx.miterLimit = 2; this.ctx.strokeText(word, currentX, y);
         }
         this.ctx.fillStyle = wordColor; this.ctx.fillText(word, currentX, y);
         currentX += this.ctx.measureText(word).width; if (idx < words.length - 1) currentX += spaceWidth;
      });
      return totalWidth;
    },

    getMousePos: function(evt) {
      const rect = this.canvas.getBoundingClientRect();
      return { 
        x: (evt.clientX - rect.left) * (this.canvas.width / rect.width), 
        y: (evt.clientY - rect.top) * (this.canvas.height / rect.height) 
      };
    },

    setupDOMEvents: function() {
      const self = this;
      // ... (Existing Event Listeners) ...
      document.getElementById('addSceneBtn').addEventListener('click', () => self.addNewScene());
      document.getElementById('langTH').addEventListener('click', () => self.setLang('th'));
      document.getElementById('langEN').addEventListener('click', () => self.setLang('en'));
      document.getElementById('btnPrevBlock').addEventListener('click', () => self.cycleBlock(-1));
      document.getElementById('btnNextBlock').addEventListener('click', () => self.cycleBlock(1));
      document.getElementById('btnAddBlock').addEventListener('click', () => self.addTextBlock());
      document.getElementById('btnDelBlock').addEventListener('click', () => self.deleteTextBlock());
      document.getElementById('modeMove').addEventListener('click', () => { self.mode = 'move'; self.els.modeBtns.move.classList.add('active'); self.els.modeBtns.censor.classList.remove('active-censor'); self.els.censorTools.style.display = 'none'; self.draw(); });
      document.getElementById('modeCensor').addEventListener('click', () => { self.mode = 'censor'; self.els.modeBtns.move.classList.remove('active'); self.els.modeBtns.censor.classList.add('active-censor'); self.els.censorTools.style.display = 'flex'; self.draw(); });
      document.getElementById('btnUndo').addEventListener('click', () => { const sc = self.scenes[self.currentSceneIndex]; sc.censoredAreas.pop(); self.draw(); });
      document.getElementById('btnClearCensor').addEventListener('click', () => { const sc = self.scenes[self.currentSceneIndex]; sc.censoredAreas = []; self.draw(); });
      document.getElementById('btnCenter').addEventListener('click', () => { /* Reset BG */ const sc = self.scenes[self.currentSceneIndex]; if (sc.imgLoaded) { sc.imgScale = Math.min(self.canvas.width/sc.img.width, self.canvas.height/sc.img.height); sc.imgX = (self.canvas.width - sc.img.width*sc.imgScale)/2; sc.imgY = (self.canvas.height - sc.img.height*sc.imgScale)/2; self.draw(); } });
      document.getElementById('btnDlPng').addEventListener('click', () => self.isDownloading = true || self.draw() || self.canvas.toBlob(b => { saveAs(b, `Scene-${self.currentSceneIndex+1}.png`); self.isDownloading = false; self.draw(); }));
      document.getElementById('downloadBtn').addEventListener('click', async () => { /* ZIP Logic Same as V51 */ });
      
      // Standard Inputs
      this.els.text.addEventListener('input', (e) => { self.scenes[self.currentSceneIndex].blocks[self.scenes[self.currentSceneIndex].activeBlockIndex].text = e.target.value; self.draw(); });
      this.els.size.addEventListener('input', (e) => { self.scenes[self.currentSceneIndex].fontSize = e.target.value; self.draw(); });
      this.els.spacing.addEventListener('input', (e) => { self.scenes[self.currentSceneIndex].lineSpacing = e.target.value; self.draw(); });
      this.els.wrap.addEventListener('input', (e) => { self.scenes[self.currentSceneIndex].textWrap = e.target.value; self.draw(); });
      this.els.pixelSize.addEventListener('input', (e) => { self.scenes[self.currentSceneIndex].pixelSize = e.target.value; self.draw(); });
      this.els.bg.addEventListener('change', () => this.draw()); this.els.stroke.addEventListener('change', () => this.draw());
      [this.els.width, this.els.height].forEach(el => el.addEventListener('change', () => this.resizeCanvas()));

      // BG Upload
      this.els.upload.addEventListener('change', (e) => {
         if (!e.target.files[0]) return;
         const reader = new FileReader();
         reader.onload = (evt) => {
             const img = new Image();
             img.onload = () => { 
                const sc = self.scenes[self.currentSceneIndex]; sc.img = img; sc.imgLoaded = true; 
                sc.imgScale = Math.min(self.canvas.width/img.width, self.canvas.height/img.height);
                sc.imgX = (self.canvas.width - img.width*sc.imgScale)/2; sc.imgY = (self.canvas.height - img.height*sc.imgScale)/2;
                self.draw();
             }; img.src = evt.target.result; self.els.upload.value = '';
         }; reader.readAsDataURL(e.target.files[0]);
      });

      // Overlay Events
      this.els.uploadOverlay.addEventListener('change', (e) => {
          if (!e.target.files[0]) return;
          const reader = new FileReader();
          reader.onload = (evt) => {
              const img = new Image();
              img.onload = () => { self.addOverlay(img); };
              img.src = evt.target.result; self.els.uploadOverlay.value = '';
          }; reader.readAsDataURL(e.target.files[0]);
      });
      this.els.ovOpacity.addEventListener('input', (e) => {
          const sc = self.scenes[self.currentSceneIndex];
          if (sc.activeOverlayIndex >= 0) {
              sc.overlays[sc.activeOverlayIndex].opacity = e.target.value / 100;
              self.updateOverlayUI(); self.draw();
          }
      });
      this.els.ovScale.addEventListener('input', (e) => {
          const sc = self.scenes[self.currentSceneIndex];
          if (sc.activeOverlayIndex >= 0) {
              const ov = sc.overlays[sc.activeOverlayIndex];
              ov.scalePercent = parseInt(e.target.value);
              const scale = ov.scalePercent / 100;
              ov.w = ov.originalW * scale; ov.h = ov.originalH * scale;
              self.updateOverlayUI(); self.draw();
          }
      });
      this.els.btnDelOverlay.addEventListener('click', () => self.deleteActiveOverlay());

      // Mouse Logic (Updated for Overlays)
      this.canvas.addEventListener('mousedown', (e) => {
          const mouse = self.getMousePos(e);
          const sc = self.scenes[self.currentSceneIndex];
          if (self.mode === 'censor') {
             if (e.button === 0) { self.isCensoring = true; self.censorStart = mouse; self.censorCurrent = mouse; }
             if (e.button === 2) { /* R-Click Logic in contextmenu */ }
          } else {
             // Move Mode Logic
             if (e.button === 0) {
                self.isDragging = true; self.dragStart = mouse;
                
                // 1. Check Text Blocks
                let hitBlock = null;
                for (let i = sc.blocks.length - 1; i >= 0; i--) {
                    const b = sc.blocks[i];
                    if (b.bounds && mouse.x >= b.bounds.x && mouse.x <= b.bounds.x + b.bounds.w && mouse.y >= b.bounds.y && mouse.y <= b.bounds.y + b.bounds.h) {
                        hitBlock = b; sc.activeBlockIndex = i; self.updateBlockUI(); break;
                    }
                }
                
                // 2. Check Overlays (If no text hit)
                let hitOverlayIndex = -1;
                if (!hitBlock) {
                    for (let i = sc.overlays.length - 1; i >= 0; i--) {
                        const ov = sc.overlays[i];
                        if (mouse.x >= ov.x && mouse.x <= ov.x + ov.w && mouse.y >= ov.y && mouse.y <= ov.y + ov.h) {
                            hitOverlayIndex = i; break;
                        }
                    }
                }

                if (hitBlock) {
                   self.dragTarget = hitBlock; self.dragOffset = { x: mouse.x - hitBlock.x, y: mouse.y - hitBlock.y };
                } else if (hitOverlayIndex !== -1) {
                   sc.activeOverlayIndex = hitOverlayIndex;
                   self.updateOverlayUI();
                   self.dragTarget = sc.overlays[hitOverlayIndex];
                   self.dragOffset = { x: mouse.x - self.dragTarget.x, y: mouse.y - self.dragTarget.y };
                } else {
                   // Clicked background -> Deselect overlay
                   sc.activeOverlayIndex = -1; self.updateOverlayUI();
                   self.dragTarget = 'image';
                }
                self.draw();
             }
          }
      });

      window.addEventListener('mouseup', () => { 
          if (self.mode === 'censor' && self.isCensoring) {
               const w = self.censorCurrent.x - self.censorStart.x;
               const h = self.censorCurrent.y - self.censorStart.y;
               if (Math.abs(w) > 5 && Math.abs(h) > 5) {
                   self.scenes[self.currentSceneIndex].censoredAreas.push({ x: self.censorStart.x, y: self.censorStart.y, w: w, h: h });
               }
               self.isCensoring = false; self.draw();
          }
          self.isDragging = false; self.dragTarget = null;
      });

      this.canvas.addEventListener('mousemove', (e) => {
         const mouse = self.getMousePos(e);
         const sc = self.scenes[self.currentSceneIndex];
         
         if (self.mode === 'censor') {
            if (self.isCensoring) { self.censorCurrent = mouse; self.draw(); }
            else {
               // Hover Logic Censor
               let found = -1;
               for (let i = sc.censoredAreas.length - 1; i >= 0; i--) {
                   const a = sc.censoredAreas[i]; const rx = a.w < 0 ? a.x+a.w : a.x; const ry = a.h < 0 ? a.y+a.h : a.y;
                   if (mouse.x>=rx && mouse.x<=rx+Math.abs(a.w) && mouse.y>=ry && mouse.y<=ry+Math.abs(a.h)) { found = i; break; }
               }
               if (found !== self.hoveredCensorIndex) { self.hoveredCensorIndex = found; self.draw(); }
            }
         } else {
            // Drag Logic
            if (self.isDragging) {
               if (self.dragTarget === 'image') {
                   sc.imgX += mouse.x - self.dragStart.x; sc.imgY += mouse.y - self.dragStart.y; self.dragStart = mouse;
               } else if (self.dragTarget) {
                   self.dragTarget.x = mouse.x - self.dragOffset.x; self.dragTarget.y = mouse.y - self.dragOffset.y;
               }
               self.draw();
            }
         }
      });
      
      this.canvas.addEventListener('contextmenu', (e) => {
          if (self.mode === 'censor') { e.preventDefault(); 
            if (self.hoveredCensorIndex !== -1) { 
                self.scenes[self.currentSceneIndex].censoredAreas.splice(self.hoveredCensorIndex, 1); 
                self.hoveredCensorIndex = -1; self.draw(); 
            }
          }
      });
    }
  };

  window.addEventListener('DOMContentLoaded', () => { window.app.init(); });
</script>
</body>
</html>
